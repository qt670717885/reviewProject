### webpack

#### 安装

```
1.yarn init

2. yarn add webpack webpack-cli --dev

```



#### 配置

在根目录下新建webpack.config.js

在package.json下配置scripts

```
"scripts" : {
    "build" : "webpack"
  },
```



**webpack.config.js**

入口 ：entry

出口 ：putput

模式 ： ‘none’，‘development’,'producetion'

```
const path = require('path');

module.exports = {
    mode: 'none', // 
    entry: './src/index.js', //入口文件路径
    output: {
        filename: 'builde.js', //出口文件路径
        path: path.join(__dirname, 'dist') //指定输出文件所在目录,这里必须是绝对路径，所以通过Node中path模块生成绝对路径
    },
    devServer:{
        contentBase:'./dist',    //服务器启动的目录
        open:true,   //自动打开浏览器
        proxy:{    //设置代理，可用于本地mock数据，本地自己启动另外一个服务
            "/api":{
                target:"http://localhost:9092"
            }
        },
        port:8083, //指定端口号
        hot:true,   //开启HMR(Hot Module Replacement)热模块替换,由于是webpack自带的，所以要引入webpack ，监控并更新js模块的工作vue等框架自己做了，否则需要自己手动监控 
        hotOnly:true
    },
    modules : {
        rules : [
            
        ]
    },
    //配置插件，是个数组，里面的项是插件的实例
    plugins:[
        //自动生成html，并移到输出目录
        new HtmlWebpackPlugin({
            title:'html模板',  
            filename:'index.html',
            template:"./index.html"     #生成html的模板路径
        }),
    ],
}
```



#### 优化

**1.使用HappyPack**

安装

```
 npm i happypack -D
```

使用

```
const HappyPack = require('happypack');
module.exports = {
	entry: './src/index.js',
	output: {
		path: path.join(__dirname, './dist'),
		filename: 'main.js',
    },
    module: {
        rules: [
            {
                test: /\.jsx?$/,
                exclude: /node_modules/,
                use: 'happypack/loader?id=babel',
            },
        ]
    },
    plugins: [
        new HappyPack({
            id: 'babel',
            threads: 4,
            loaders: ['babel-loader']
        }),
    ]
}
/**
id: id值，与loader配置项对应
threads: 配置多少个子进程
loaders: 用什么loader处理
*/

```



#### 2. 使用缓存

每次构建可以缓存不被修改的文件，大部分loader提供了cache配置项，比如babel-loader通过设置cacheDirectory:true来实现。如果不支持缓存的laoder也可以使用cache-loader到磁盘

````
	 {
        test: /\.js$/,
        use: ['cache-loader', 'babel-loader'],
        include: path.resolve('src'),
      },
````



#### 3. 抽离不常变更的静态依赖

- 使用 [`webpack-dll-plugin`](https://webpack.docschina.org/plugins/dll-plugin/) 的方式，在首次构建时候就将这些静态依赖单独打包，后续只需要引用这个早就被打好的静态依赖包即可
- 另一种，也是业内常见的 [`Externals`](https://webpack.docschina.org/configuration/externals/)的方式，我们将这些不需要打包的静态资源从构建逻辑中剔除出去，而使用 CDN 的方式，去引用它们。



#### 4. 尽可能少的文件被Loader处理

因为loader处理文件话费大量时间，尽可能减少文件被loader处理

```
{
    test: /\.js$/,
    use: [
        'babel-loader?cacheDirectory',//开启转换结果缓存
    ],
    include: path.resolve(__dirname, 'src'),//只对src目录中文件采用babel-loader
    exclude: path.resolve(__dirname,' ./node_modules'),//排除node_modules目录下的文件
},
```





#### 5.使用devserver开启本地服务器

使用devserve开启本地服务器

```
devServer: {
  contentBase: path.join(__dirname, "dist"),
  compress: true,
  port: 9000,
  hot: true,
  historyApiFallback: true, // 该选项的作用所有的404都连接到index.html
    proxy: {
      // 代理到后端的服务地址，会拦截所有以api开头的请求地址
      "/api": "http://localhost:3000"
    }
}
```



#### 5. 开启压缩

使用producetion模式自动开启压缩

