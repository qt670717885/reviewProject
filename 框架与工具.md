### Vue

#### 1. 对于MVVM的理解

MVVM分为三个部分，Mddel层，view层，ViewModel层

- Model层为数据模型，在Model中操作数据
- view层代表UI组件，负责数据模型转化为视图
- ViewModel层 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View。

**ViewModel** 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。

![bg2015020110.png](https://segmentfault.com/img/bVCU4O)

#### 2. Vue实现双向数据绑定的原理

主要是Object.defineProperty()进行数据劫持结合发布订阅模式实现的。Object.defineProperty()将每个属性劫持设置setter与getter。在数据变动时发布信息给订阅者，触发监听回调。



#### 3. Vue生命周期

1. Vue的生命周期从创建一个Vue实例开始，之后Vue要进行初始化事件和初始化生命周期。

2. 执行beforeCreate钩子函数，这个函数执行在初始化之后，创建组件之前，所以还不能访问数据，组件中的data，ref都为undefind。

3. 进入了初始化中，初始化data和props，并且给数据绑定上数据劫持

4. 执行created钩子函数，这个函数在组件创建完成后立即被调用，组件中有了data对象，可以操作data，可以发请求和访问数据了，ref依然为undefind。因为还没有挂载，所以el不可用。

5. 进行编译选项，是否有el或template，再根据编译选项作为模板将数据和compile函数(编译函数)进行结合，创建出虚拟DOM对象。

以上初始化阶段完成，下面来描述创建过程

1. 数据挂载前先执行beforeMount钩子函数，页面还没有创建出HTML元素，data初始化已经完成，虚拟dom已经存在
2. 创建vm.$el来替换el，并切换掉原有的编译模板，生成一个真正可用的HTML
3. 完成页面的数据挂载后执行Mounted，这时可以操作数据和DOM了

以上，创建阶段描述完了，接下来是数据更新时

1. 当数据被更新时调用beforeUpdate钩子函数，它在页面数据更新之前调用，并监听数据的变化，但不可以在这里更改数据
2. 虚拟DOM重新渲染并应用更新
3. updated数据更新完毕 在这个生命周期钩子函数中 我们可以获取到当前最新的数据（也就是页面中的最新数据）

以上，更新阶段描述完了，接下来是销毁阶段

1. 当调用vm.$destroy()函数时，进入销毁阶段
2. beforeDestroy 销毁之前 还是可以使用HTML的，也可以获取到数据
3. 销毁中 终止对象劫持（最主要）子组件，事件
4. destroyed 销毁之后 我们对 Vue实例提供的DOM操作就无效了 但是还是可以获取到数据的

另外，keep-alive中海油两个生命周期

​	activated：组件被激活时调用

​	deactivated ： 组件被销毁时调用

##### 3.1 在哪个生命周期内调用异步请求？

在 钩子函数 created 、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务器点的数据返回进行赋值。

##### 3.2 什么阶段可以操作DOM

在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以可以在 mounted 中访问到 DOM。



#### 4. keep-alive的理解

keep-alive 是 Vue 内置的一个组件，可以使用包含的组件保留状态，避免重复渲染。

1. 一般结合路由和动态组件一起使用，用于缓存组件
2. 提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；
3. 对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。



#### 5. Vue中computed和watch的区别

- 功能上：computed 是计算属性，也就是依赖其它的属性计算后所得出的值。 watch是去监听一个值的变化，然后执行相应的函数
- 使用上：computed 中的函数必须使用 return 返回；，watch 的回调里面传入监听属性的新旧值，通过这两个值可以做一些特定的操作，不是必须要return
- 性能上：computed 中的函数所依赖的属性没有发生变化，那么调用当前函数的时候回从缓存中读取，而 watch 在每次监听值发生变化的时候都会执行回调，支持对属性的深度监听。
- 场景上：computed 当一个属性受多个属性影响的时候，例如：商品结算；watch：当一条数据影响多个数据的时候。例如：分页



#### 6. 插槽

插槽slot的作用:子组件内使用特殊的＜slot>元素就可以为这个子组件开启一个slot（插槽），在父组件模板里，插入在子组件标签内的所有内容将替代子组件的＜slot> 标签及它的内容。

```vue
//单个插槽的使用
// 父组件
<template>
  <div class="home">
    <childSlot></childSlot>
  </div>
</template>

// 子组件
<template>
  <div class="">
    <slot>
        <p>这是插槽内容</p>
    </slot>
  </div>
</template>

```

这时就显示的是slot中的内容



- 具名插槽

  当我们需要多个插槽时我们需要在<slot>标签中使用name属性

  ```vue
  //子组件
  <template>
    <div class="">
      <slot name="header">
        <p>这是header插槽内容</p>
      </slot>
      <slot name="body">
        <p>这是body插槽内容</p>
      </slot>
      <slot name="bottom">
        <p>这是bottom插槽内容</p>
      </slot>
    </div>
  </template>
  // 父组件中使用slot来判别名称（已废弃，建议使用v-slot）
  <template>
    <div class="home">
      <childSlot>
          <div slot="header">
          </div>
          <div slot="bosy">
          </div>
          <div slot="bottom">
          </div>
      </childSlot>
    </div>
  </template>
  // 父组件中也可以定义<template>,再使用v-slot标签
  <template>
    <div class="home">
      <childSlot>
          <template v-slot:header> </template >
          <template v-slot:body></template>
          <template v-slot:bottom></template>
      </childSlot>
    </div>
  </template>
  ```

- 作用域插槽

  有时候想让插槽能够访问子组件中才有的数据，这时候就需要作用域插槽。

  子组件通过v-vind:数据名=“数据”,绑定数据

  父组件中使用v-slot来定义我们提供的插槽 prop 的名字

  ```
  //子组件
  <template>
    <div class="child">
      <slot v-bind:name="name">
          {{name}}
      </slot>
    </div>
  </template>
  
  <script>
  export default {
    name: "childSlot",
    data() {
      return {
          name : 'qqq'
      };
    },
  };
  </script>
  ```

  ```
  // 父组件
  <template>
    <div class="home">
      <childSlot>
        <template v-slot:default="slotProps">
          {{ slotProps.name }}
        </template>
      </childSlot>
    </div>
  </template>
  ```



#### 7. Vue自定义指令的方法，有哪些钩子函数，还有哪些钩子函数参数？

使用Vue.directive命令注册一个全局指令

```

```



#### 8. Vue中的MVVM架构与MVC架构与MVP架构

- MVC机构
  - 视图层(view) : 用户界面
  - 控制层(controll) : 业务逻辑
  - 模型(Model):数据保存


#### 9. keep-alive的使用
[keep-alive的使用](./Vue/markdown/keep-alive.md)






### Vue-router

#### 1. Vue-router的动态路由

```
const router = new VueRouter({
  routes: [
    // 动态路径参数 以冒号开头
    { path: '/user/:id', component: User }
  ]
})
```

使用$route.params.id获取



#### 2. Vue-router的导航钩子

分为三种

1. 全局导航钩子 ：

   1. router.beforeEach((to,from,next)=>{})
   2. router.beforeResolve((to,from,next)=>{})
   3. router.aferEach((to,from)=>{})

2. 路由独享守卫

   beforeEnter

   ```
   const router = new VueRouter({
     routes: [
       {
         path: '/foo',
         component: Foo,
         beforeEnter: (to, from, next) => {
           // ...
         }
       }
     ]
   })
   ```

3. 组件内的守卫

   可以在路由组件内直接定义以下路由导航守卫：

   - `beforeRouteEnter`
   - `beforeRouteUpdate` (2.2 新增)
   - `beforeRouteLeave`

   ```
   const Foo = {
     template: `...`,
     beforeRouteEnter (to, from, next) {
       // 在渲染该组件的对应路由被 confirm 前调用
       // 不！能！获取组件实例 `this`
       // 因为当守卫执行前，组件实例还没被创建
     },
     beforeRouteUpdate (to, from, next) {
       // 在当前路由改变，但是该组件被复用时调用
       // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
       // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
       // 可以访问组件实例 `this`
     },
     beforeRouteLeave (to, from, next) {
       // 导航离开该组件的对应路由时调用
       // 可以访问组件实例 `this`
     }
   }
   ```

   `beforeRouteEnter` 守卫 **不能** 访问 `this`，因为守卫在导航确认前被调用，因此即将登场的新组件还没被创建。



#### 3. 完整的导航解析流程

1. 导航被触发。

2. 在失活的组件里调用 `beforeRouteLeave` 守卫。

3. 调用全局的 `beforeEach` 守卫。

4. 在重用的组件里调用 `beforeRouteUpdate` 守卫 (2.2+)。

5. 在路由配置里调用 `beforeEnter`。

6. 解析异步路由组件。

7. 在被激活的组件里调用 `beforeRouteEnter`。

8. 调用全局的 `beforeResolve` 守卫 (2.5+)。

9. 导航被确认。

10. 调用全局的 `afterEach` 钩子。

11. 触发 DOM 更新。

12. 调用 `beforeRouteEnter` 守卫中传给 `next` 的回调函数，创建好的组件实例会作为回调函数的参数传入。

    

#### 4. $route与$router的区别

- $route对象表示当前的路由信息，里面包含name，path，params，query等信息

```
{name: "Home", meta: {…}, path: "/", hash: "", query: {…}, …}
fullPath: "/"
hash: ""
matched: [{…}]
meta: {}
name: "Home"
params: {}
path: "/"
query: {}
__proto__: Object
```

- $router是VueRouter的实例，包含了路由的跳转方法，钩子函数等



#### 5. Vue-router的两种模式

- hash

  原理是onhashchange事件

  ```
  window.onhashchange = function(event){
    console.log(event.oldURL, event.newURL)
    let hash = location.hash.slice(1)
  }
  ```

- history

  - 利用了HTML5 History Interface 中新增的pushState()和replaceState()方法。
  - 需要后台配置支持。如果刷新时，服务器没有响应响应的资源，会刷出404，



#### 6. vue-router实现路由懒加载

把不同路由对应的组件分割成不同的代码块，然后当路由被访问时才加载对应的组件即为路由的懒加载，可以加快项目的加载速度，提高效率

```
const router = new VueRouter({
  routes: [
    {
      path: '/home',
      name: 'Home'，
      component:() = import('../views/home')
        }
  ]
})
```



### Vuex

[vuex](./Vue/markdown/Vuex.md)



### axios
[axios](./axios/基本教程.md)













