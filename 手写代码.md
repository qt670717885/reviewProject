手写代码

CSS部分：

- [ ] 两栏布局
- [ ] 三栏布局
- [ ] 圣杯布局与双飞翼布局
- [ ] 居中方式

JS部分：

- [ ] call、bind、apply

  ```js
  //call
  Function.prototype.myCall = function (context) {
      if(typeof this !== 'function'){
          throw new TypeError('Error');
      }
      context = context || window
      context.fn = this
      const args = [...arguments].slice(1)
      const result = context.fn(...args)
      delete context.fn
      return result
  
  }
  
  ```

  ```
  //apply
  
  ```

- [ ] promise

- [ ] 防抖节流

  ```js
  // 防抖
  function debounce(fn, delay) {
      let timer = null
      return function () {
          if (timer) {
              clearTimeout(timer) //进入该分支语句，说明当前正在一个计时过程中，并且又触发了相同事件。所以要取消当前的计时，重新开始计时
          }
          timer = setTimeout(fn, delay) // 进入该分支说明当前并没有在计时，那么就开始一个计时
      }
  }
  
  ```

  ```
  // 节流
  ```

  

- [ ] 深浅拷贝

  ```js
  //对象浅拷贝 Object.assgin
  newObj = Object.assgin({},obj)
  ```

  ```js
  // 浅拷贝
  function shallowClone(initalObj) {
      var obj = {};
      for (var i in initalObj) {
          obj[i] = initalObj[i];
      }
      return obj;
  }
  ```

  ```js
  // Array.prototype.concat()与Array.prototype.slice()也是浅拷贝
  let arr = [1, 3, {
  
      username: 'kobe'
  
      }];
  
  let arr2=arr.concat();    
  
  arr2[2].username = 'wade';
  
  console.log(arr);
  
  //-------------------------------------------------
  let arr = [1, 3, {
  
      username: ' kobe'
  
      }];
  
  let arr3 = arr.slice();
  
  arr3[2].username = 'wade'
  
  console.log(arr);
  ```

  ```
  // JSON.parse(),JSON.Stringify()拷贝
  // 缺点是不能拷贝函数与正则
  let arr = [1, 3, {
      username: ' kobe'
  },function(){}];
  
  let arr4 = JSON.parse(JSON.stringify(arr));
  
  arr4[2].username = 'duncan';
  
  console.log(arr, arr4)
  ```

  ```js
  // 递归进行深拷贝
  function deepClone (obj) {
      if(!obj && typeof obj !== 'object'){
          throw new Error('error arguments')
      }
  
      const targetObj = Array.isArray(obj) ? [] : {}
      for(let key in obj){
          if(obj.hasOwnProperty(key)) {
              if(obj[key] && typeof obj[key] === 'object') {
                  targetObj[key] = deepClone(obj[key])
              }else{
                  targetObj[key] = obj[key]
              }
          }
      }
      return targetObj
  }
  ```

- [ ] 数组拍平、去重

- [ ] 数组高阶函数API手写

- [ ] new的原理

  ```
  function  myNew(context,...params){
      //1.以构造器的prototype属性为原型，创建新对象；
      //2.改变this指向
      //3.如果构造器没有手动返回对象，则返回第一步的对象
      let obj = Object.create(context.prototype)
      let result = context.apply(obj,params)
      return typeof result === 'object' ? result : obj
  }
  
  ```

- [ ] 冒泡排序，快速排序

